

# HTML

### ***1.src 和 href 的区别

src 和 href 都是**用来引用外部的资源**，它们的区别如下：

·  **src：**表示**对资源的引用**，它指向的内容会嵌入到当前标签所在的位置。src 会将其指向的资源下载并应用到文档内，如请求 js 脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，所以一般 js 脚本会放在页面底部。

·  **href：**表示**超文本引用**，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它指向的文件时，就会并行下载资源，不会停止对当前文档的处理。 常用在a、link等标签上。



### ***2.对HTML 语义化的理解

**语义化是指根据内容的结构化(内容语义化)，选择合适的标签(代码语义化)。**就是用正确的标签做正确的事情。

**优点：**

·  对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；

·  对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。

常见的语义化标签：

```html
<header></header>   //头部
<nav></nav>         //导航栏
<section></section> //区块（有语义化的div）
<main></main>       //主要区域
<article></article> //主要内容
<aside></aside>     //侧边栏
<footer></footer>   //底部
```





### **3.DOCTYPE（文档类型）的作用

DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是**告诉浏览器(解析器)应该以什么样(html或xhtml)的文档类型定义来解析文档**，不同的染模式会影响浏览器对 CSS 代码甚至 JavaScript 脚本的解析。它必须声明在HTML文档的第一行。



浏览器渲染页面的两种模式(可通过document.compatMode获取，比如，语雀官网的文档类型是css1Compat)"

·  **Css1Compat: 标准模式 (Strick mode)**，默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面

·  **BackCompat: 怪异模式(混杂模式)（Quick mode)**，浏览器使用自己的怪异模式解析染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。







### ***4.script 标签中 defer 和 async 的区别

如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。



**defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析**，其区别如下：

**·  执行顺序：**多人带async属性的标签，不能保证加载的顺序，多人带defer属性的标签，按照加载顺序执行；

·  **脚本是否并行执行：** async属性，表示**后续文档的加载和执行与js脚本的加载和执行是并行进行的**，即异步执行;defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。





### **5.常用的 meta 标签有哪些

meta 标签由 name 和 content 属性定义，**用来描述网页文档的属性**，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些 name 作为大家使用的共识，开发者还可以自定义name。

常用的 meta 标签：

（1）charset，用来描述HTML文档的编码类型

```html
<meta charset="UTF-8" >
```

（2）keywords，页面关键词

```html
<meta name="keyword" content="关键词" />
```

（3）description，页面描述

```html
<meta name="description" content="页面描述内容" />
```

（4）refresh，页面重定向和刷新

```html
<meta http-equiv="refresh" content="0;url=" />
```

（5）viewport，适配移动端，可以控制视口大小和比例

```html
<meta name="viewport" content="width=device-width,initial-scle=1,maximum-scale=1" >
```

其中，content参数有以下几种

·  width viewport ：宽度(数值/device-width)

·  height viewport ：高度(数值/device-height)

·  initial-scale ：初始缩放比例

·  maximum-scale ：最大缩放比例

·  minimum-scale ：最小缩放比例

·  user-scalable ： 是否允许用户缩放(yes/no)

（6）搜索引擎索引方式

```html
<meta name="robots" content="index,follow">
```

其中，content参数有以下几种

·  all ： 文件将被检索，且页面上的链接可以被查询

· none ：文件将不被检索，且页面上的链接不可以被查询

·  iindex ：文件将被检索

·  follow ：页面上的链接可以被查询

·  noindex ：文件将不被检索

·  nofollow ： 页面上的链接不可以被查询







### ***6.HTML5有哪些更新

##### 1.语义化标签

·  header: 定义文档的页眉(头部)

·  nav: 定义导航链接的部分

·  footer: 定义文档或节的页脚 (底部)

·  article: 定义文章内容

·  section: 定义文档中的节 (section、区段) 

·  aside: 定义其所处内容之外的内容(侧边)



##### 2.媒体标签

（1）audio：音频

```html
<audio src='controls autoplay loop='true'></audio>
```

属性：

·  controls 控制面板

·  autoplay 自动播放

·  loop=“true’循环播放

（2）video视频

```html
<video src='' poster=' imgs/aa.jpg' controls></video>
```

属性：

·  poster： 指定视频还没有完全下载完毕，或者用户还没有点击播放前显示的封面。默认显示当前视频文件的第一针画面，当然通过poster也可以自己指定

·  controls 控制面板

·  width

·  height

（3）source标签

因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过source来指定视频源

```html
<video>
<source src='aa.flv' type='video/flv'></source>
<source src='aa.mp4' type='video/mp4'></source>
</video>
```

##### 3.表单

**表单类型：**

·  email : 能够验证当前输入的邮箱地址是否合法

·  url: 验证URL

·  height

·  number : 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max属性可以设置为最大值，min可以设置为最小值，value为默认值。

·  search : 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化

·  range ：可以提供给一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值

·  color： 提供了一个颜色拾取器

·  time：时分秒

·  date：日期选择年月日

·  datetime: 时间和日期(目前只有Safari支持）

·  datatime-local : 日期时间控件

·  week : 周控件

·  month: 月控件

**表单属性：**

·  placeholder: 提示信息

·  autofocus: 自动获取焦点

·  autocomplete=“on”或者 autocomplete=“off”使用这个属性需要有两个前提：

​	·  表单必须提交过

​	·  必须有name属性

· required: 要求输入框不能为空，必须有值才能够提交

·  date：日期选择年月日

·  pattern=" ” 里面写入想要的正则模式，例如手机号patte="^(+86)? dr101S"

·  multiple: 可以选择多人文件或者多人邮箱

·  form="form表单的ID"

**表单事件**

·  oninput 每当input里的输入框内容发生变化都会触发此事件

·  oninvalid 当验证不通过时触发此事件

##### 4.进度条、度量器

·  progress标签: 用来表示任务的进度 (IE、Safari不支持)，max用来表示任务的进度，value表示已完成多少

·  meter标签: 用来显示剩余容量或剩余库存 (IE、Safari不支持)

·  

​	·   high/low: 规定被视作高/低的范围

​	·  max/min: 规定最大/小值

​	·  value: 规定当前度量值

设置规则: min < low < high < max



##### 5.DOM查询操作

·  document.querySelector()

·  document.querySelectorAll()

它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)



##### 6.Web存储

HTML5 提供了两种在客户端存储数据的新方法:

·  localstorage- 没有时间限制的数据存储

·  sessionstorage - 针对一个 session 的数据存储

##### 7.其他

·  拖放: 拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放:

```html
<img draggable="true"/>
```

· 画布(canvas): canvas 元素使用JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。

```html
<canvas id="myCanvas" width="200" height="100"></canvas>
```

·  SVG: SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准

·  地理定位: Geolocation (地理定位) 用于定位用户的位置。



##### 总结

1. 新增语义化标签: nav、 header、footer、aside、 section、article
2.  音频、视频标签: audio、video
3. 数据存储: localStorage、 sessionStorage
4. canvas (画布)、Geolocation (地理定位) 、websocket (通信协议)
5. input标签新增属性: placeholder、autocomplete、 autofocus、required
6.  history APl: go、forward、 back、pushstate



移除的元素有:

·  纯表现的元素: basefont，big，center，font, s，strike，tt，u;

·  对可用性产生负面影响的元素: frame，frameset，noframes;



### *7.img的srcset属性的作用

响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。



srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸零界点。对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片



### ***8.行内元素有哪些？块级元素有哪些？空（void）元素有哪些？

·  行内元素有：a b span img input select strong ;

·  块级元素有： div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p ;

空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签

·  常见的有

```html
<br>、<hr> 、<img> 、<input> 、<link>
```

·  鲜见的有:

```html
<area>、<base>、<col>、<colgroup> 、<param>、<source>、<track>、<wbr>、<meta>
```



### **9.说一下 web worker

在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了

如何创建 web worker:

1. 检测浏览器对于 web worker 的支持性

2. 创建 web worker 文件 (js，回传函数等）

3. 创建 web worker 对象



### *10.HTML5的离线存储怎么使用，它的工作原理是什么

##### 离线存储指的是：

在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。

##### 原理：

HTML5的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示

##### 使用方法：

1. 创建个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性

   ```html
   <html lang="en” manifest="index.manifest">
   ```

2. 在 cache.manifest 文件中编写需要离线存储的资源：

   ```html
   CACHE MANIFEST
   	#v0.11
   	CACHE:
   	js/app.js
   	css/style.css
   	NETWORK :
   	resourse/logo.png
   	FALLBACK:
   	//offline.html
   ```

   ·  **CACHE：** 表示需要离线存诸的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页
   面自身也列出来。

   ·  **NETWORK：**表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。

   ·  **FALLBACK:** 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html。

3. 在离线状态时，操作 window.applicationCache 进行离线缓存的操作。

##### 如何更新缓存：

1. 更新 manifest 文件
2.  通过javascript 操作
3. 清除浏览器缓存

##### 注意事项：

1. 浏览器对缓存数据的容量限制可能不太一样(某些浏览器设置的限制是每个站点 5MB)
2. 如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存
3. 引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下
4.  FALLBACK 中的资源必须和 manifest 文件同源
5. )当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。
6. 站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。
7. 当 manifest 文件发生改变时，资源请求本身也会触发更新



### *11.浏览器是如何对HTML5的离线存储资源进行管理和加载？

·  **在线的情况下**，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。

·  **离线的情况下**，浏览器会直接使用离线存储的资源





### **12.title与h1的区别、b与strong的区别、i与em的区别

·  strong标签有语义，是起到加重语气的效果，而b标签是没有的，b标签只是一个简单加粗标签。b标签之间的字符都设为粗体，strong标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重strong标签

·  title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取有很大的影响

·  i 内容展示为斜体，em表示强调的文本









### 13.iframe 有哪些优点和缺点

iframe 元素会创建包含另外一个文档的内联框架 (即行内框架)

**优点：**

·  用来加载速度较慢的内容(如广告)

·  可以使脚本可以并行下载

·  可以实现跨子域通信

**缺点：**

·  iframe 会阻塞主页面的 onload 事件

·  无法被一些搜索引擎索识别

·  会产生很多页面，不容易管理







### *14.label 的作用是什么？如何使用？

label标签来定义表单控件的关系: 当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上



### **15.Canvas和SVG的区别

##### 1.SVG：

SVG可缩放矢量图形(Scalable Vector Graphics) 是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某人元素附加Javascript事件外理器。在 SVG 中，每被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。

其特点如下：

·  不依赖分辨率

·  支持事件外理器

·  最适合带有大型渲染区域的应用程序(比如谷歌地图)

·  复杂度高会减慢渲染速度(任何过度使用 DOM 的应用都不快)

·  不适合游戏应用

##### 2.Canvas

Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。

其特点如下：

·  依赖分辨率

·  不支持事件外理器

·  弱的文本渲染能力

·  能够以.png 或.jpg 格式保存结果图像

·  最适合图像密集型的游戏，其中的许多对象会被频繁重绘

注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。









### **16.head 标签有什么用，其中什么标签必不可少？

文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。

head标签中最重要的标签是title标签，它用于定义文档的标题，是必不可少的。除了title标签外，head标签还可以包含其他标签，如meta、link、script等，用于定义文档的元信息和引用外部资源。head标签中的内容不会在浏览器中显示，但是它对于SEO和网站性能优化非常重要。















# CSS

### ***1.CSS选择器及其优先级

| 选择器         | 格式          | 优先级权重 |
| -------------- | ------------- | ---------- |
| id选择器       | #id           | 100        |
| 类选择器       | .classname    | 10         |
| 属性选择器     | a[ref="eee"]  | 10         |
| 伪类选择器     | li:last-child | 10         |
| 标签选择器     | div           | 1          |
| 伪元素选择器   | li:after      | 1          |
| 相邻兄弟选择器 | h1+p          | 0          |
| 子选择器       | ul>li         | 0          |
| 后代选择器     | li a          | 0          |
| 通配符选择器   | *             | 0          |

对于选择器的**优先级**:

·  标签选择器、伪元素选择器: 1

·  类选择器、伪类选择器、属性选择器: 10

·  id 选择器: 100

·  内联样式: 1000



**注意事项：**

·  !important 声明的样式的优先级最高

·  如果优先级相同，则最后出现的样式生效

·  继承得到的样式的优先级最低

·  通用选择器(*)、子选择器 (>) 和相邻同胞选择器(+)并不在这四人等级中，所以它们的权值都为 0，

·  样式表的来源不同时，优先级顺序为: 内联样式>内部样式>外部样式>浏览器用户自定义样式>浏览器默认样式



### **2.CSS中可继承与不可继承属性有哪些

##### 一、无继承性的属性

1. **display:** 规定元素应该生成的框的类型

2. **文本属性:**

   ·  vertical-align: 垂直文本对齐

   ·  text-decoration: 规定添加到文本的装饰

   ·  text-shadow: 文本阴影效果

   ·  white-space：空白符的处理

   ·  unicode-bidi: 设置文本的方向

3. **盒子模型的属性:** width、 height、 margin、border、 padding

4. **背景属性:** background、background-color、background-image、background-repeat、backgroundposition、background-attachment

5. **定位属性:** float、clear、position、 top、 right、 bottom、 left、 min-width、 min-height、 max-width、 max3height、 overflow、clip、z-index

6. **生成内容属性:** content、 counter-reset、 counter-increment

7. **轮廓样式属性:** outline-style、 outline-width、 outline-color、 outline

8. **页面样式属性:** size、 page-break-before、 page-break-after

9. **声音样式属性:** pause-before、 pause-after、 pause、 cue-before、 cue-after、 cue、 play-during

##### 二、有继承性的属性

1. **字体系列属性**

   ·  font-family: 字体系列

   ·  font-weight: 字体的粗细

   ·  font-size: 字体的大小

   ·  font-style: 字体的风格

2. **文本系列属性**

   ·  text-indent:文本缩讲

   ·  text-align: 文本水平对文

   ·  line-height: 行高

   ·  word-spacing: 单词之间的间距

   ·  letter-spacing: 中文或者字母之间的间距

   ·  text-transform: 控制文本大小写(就是uppercase、lowercase、capitalize这三个)

   ·  color: 文本颜色

3. **元素可见性**

   ·  visibility: 控制元素显示隐藏

4. **列表布局属性**

   ·  list-style: 列表风格，包括list-style-type、list-style-image等

5. **光标属性**

   ·  cursor：光标显示为何种形态









### ***3.display的属性值及其作用

| 属性值       | 作用                                                     |
| ------------ | -------------------------------------------------------- |
| none         | 元素不显示，并且会从文档流中移除                         |
| block        | 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。     |
| inline       | 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示 |
| inline-block | 默认宽度为内容宽度，可以设置宽高，同行显示               |
| list-item    | 像块类型元素一样显示，并添加样式列表标记                 |
| table        | 此元素会作为块级表格来显示                               |
| inherit      | 规定应该从父元素继承display属性的值                      |



### ***4.display的block、inline和inline-block的区别

1. **block:** 会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性
2.  **inline:** 元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin
3.  **inline-block:** 将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。

对于行内元素和块级元素，其特点如下:

1. **行内元素**

   ·  设置宽高无效

   ·  可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin

   ·  不会自动换行

2. **块级元素**

   ·  可以设置宽高

   ·  设置margin和padding都有效

   ·  可以自动换行

   ·  多个块状，默认排列从上到下







### ***5.隐藏元素的方法有哪些

·  **display: none:** 渲染树不会包含该染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。

·  **visibility: hidden:** 元素在页面中仍占据空间，但是不会响应绑定的监听事件

·  **opacity: 0:** 将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。

·  **position： absolute:** 通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏

·  **z-index: 负值:** 来使其他元素遮盖住该元素，以此来实现隐藏。

·  **clip/clip-path :** 使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。

·  **transform: scale(0,0):** 将元素缩放为0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。





### **6.link和@import的区别

两者都是外部引用CSS的方式，它们的区别如下：

· link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务，@import属于CSS范畴，只能加载CSS

·  link引用CSS时，在页面载入时同时加载，@import需要页面网页完全载入以后加载

·  link是XHTML标签，无兼容问题;@import是在CSS2.1提出的，低版本的浏览器不支持

·  link支持使用Javascript控制DOM去改变样式，而@import不支持





### *7.transition和animation的区别

·  **transition是过度属性**，强调过度，它的实现需要触发一个事件(比如鼠标移动上去，焦点，点击等)才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键顿。

·  **animation是动画属性**，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键顿 (用@keyframe定义) 完成动画。



### ***8.display：none 与 visibility：hidden的区别

这两个属性都是让元素隐藏，不可见。**两者区别如下：**

1. **在渲染树中**

   ·  display:none 会让元素完全从渲染树中消失，渲染时不会占据任何空间;

   ·  visibility:hidden 不会让元素从染树中消失，渲染的元素还会占据相应的空间，只是内容不可见

2. **是否是继承属性**

   ·  display:none 是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示

   ·  visibility:hidden 是继承属性，子孙节点消失是由于继承了 hidden ，通过设置 visibility:visible 可以让子孙节点显示

3. 修改常规文档流中元素的 display 通常会造成文档的重排，但是修改 visibilty 属性只会造成本元素的重绘

4. 如果使用读屏器，设置为 display:none 的内容不会被读取，设置为 visibility:hidden 的内容会被读取











### **9.伪元素和伪类的区别和作用

·  伪元素:在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。

·  伪类:将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。

**总结：**伪类是通过在元素选择器上加入伪类改变元素状态，而伪元素通过对元素的操作进行对元素的改变



### 10.对requestAnimationframe的理解



### ***11.对盒模型的理解

CSS3中盒模型有以下两种：标准盒子模型、IE盒子模型

![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603600820746-e10daafa-451a-454e-9705-f8c358769d5b.png?x-oss-process=image%2Fresize%2Cw_746%2Climit_0#align=left&display=inline&height=366&margin=%5Bobject%20Object%5D&originHeight=455&originWidth=746&size=0&status=done&style=none&width=600?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_21%2Ctext_5pyI5ZOl55qE6Z2i6K-V6K6t57uD6JCl%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603600820555-dc6ed390-d47e-412b-942a-857bbe5f280d.png?x-oss-process=image%2Fresize%2Cw_746%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_21%2Ctext_5pyI5ZOl55qE6Z2i6K-V6K6t57uD6JCl%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fresize%2Cw_746%2Climit_0#align=left&display=inline&height=368&margin=%5Bobject%20Object%5D&originHeight=462&originWidth=791&size=0&status=done&style=none&width=630)

盒模型都是由四个部分组成的，分别是margin、border、 padding和content。

标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同:

·  标准盒模型的width和height属性的范围只包含了content

·  IE盒模型的width和height属性的范围包含了border、 padding和content.

可以通过修改元素的box-sizing属性来改变元素的盒模型：

·  box-sizeing: content-box 表示标准盒模型 (默认值)

·  box-sizeing: border-box 表示IE盒模型 (怪异盒模型）







### 12.为什么有时候用translate来改变位置而不是定位

translate 是 transform 属性的一个值。改变transform或opacity不会触发浏览器重新布局 (reflow)或重绘(repaint) ，只会触发复合 (compositions)。而改变绝对定位会触发重新布局，进而触发重绘和复合。transform使浏览器为元素创建一个 GPU 图层，但改变绝对定位会使用到 CPU。因此translate（）更高效，可以缩短平滑动画的绘制时间。而translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发生这种情况





### 13.li 与 li 之间有看不见空白间隔是什么原因引起的？如何解决？

浏览器会把inline内联元素间的空白字符(空格、换行、Tab等) 染成一个空格。为了美观，通常是一个<li>放在一行，这导致<li>换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。

**解决办法:**

(1)为<li> 设置float:left。不足: 有些容器是不能设置浮动，如左右切换的焦点图等

(2) 将所有 <li> 写在同一行。不足: 代码不美观。

(3)将 <u1> 内的字符尺寸直接设为0，即font-size:0。不足:<u1> 中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，目在Safari浏览器依然会出现空白间隔.

(4)消除<ul>的字符间隔letter-spacing:-8px，不足: 这也设置了<li>内的字符间隔，因此需要将<li>内的字符间隔设为默认letter-spacing:normal。







### ***14.CSS3有哪些新特性

·  新增各种CSS选择器 (: not(input): 所有 cass 不是“input”的节点)
·  圆角 (border-radius:8px)
·  多列布局 (multi-column layout)0
·  阴影和反射 (shadoweflect)
·  文字特效 (text-shadow)
·  文字渲染 (Text-decoration)
·  线性渐变 (gradient)
·  旋转 (transform)
·  增加了旋转.缩放,定位,倾斜,动画,多背景







### 15.替换元素的概念及计算规则

通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。

替换元素除了内容可替换这一特性以外，还有以下特性:

·  **内容的外观不受页面上的CSS的影响**: 用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素不身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口。

·  **有自己的尺寸**: 在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸(不包括边框)是300像素x150像素

·  **在很多CSS属性上有自己的一套表现规则**: 比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。

·  **所有的替换元素都是内联水平元素**: 也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。

替换元素的尺寸从内而外分为三类:

·  **固有尺寸：**指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。

·  **HTML尺寸:** 只能通过HTML原生属性改变，这些HTML原生属性包括的width和height属性、size属性

·  **CSS尺寸:** 特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的content box。

这三层结构的计算规则具体如下：

1. 如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高
2. 如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高
3. 如果有CSS尺寸，则最终尺寸由CSS属性决定
4. 如果“固有尺寸”合有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示
5. 如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素
6. 内联替换元素和块级替换元素使用上面同一套尺寸计算规则







### **16.常见的图片格式及使用场景

1. **BMP**，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。

2. **GIF**是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同
   时需要文件体积较小的场景.

3. **JPEG**是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模常适合用来存储照片糊，而直接色的选用，又会导致图片文件较GIF更大。

4. **PNG-8**是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。

5. **PNG-24**是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多

6. **SVG**是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logolcon等。

7. **WebP**是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢? 就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持Webp格式，兼容性不太好。

   ·  在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%;

   ·  在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%;

   ·  WebP图一格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小









### **17.对CSSprites的理解

CsSSprites (精灵图)，将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 backqroundimage，background-repeat，background-position属性的组合进行背景定位

**优点：**

·  利用 css Sprites 能很好地减少网页的http请求，从而大大提高了页面的性能，这是 CSS Sprites 最大的优点;

·  Css Sprites 能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。

**缺点：**

·  在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂，

·  CsSSprites 在开发的时候相对来说有点麻烦，需要借助 photoshop 或其他工具来对每人背单元测量其准确的位置。

·  维护方面: CSS Sprites 在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的 CSS ，如果在原来的地方放不下，又只能(最好)往下加图片，这样图片的字节就增加了，还要改动 Css











































































# JavaScript



## 基础八股

### 事件流

##### 概念

JavaScript 事件流 (Event flow) 指的是浏览器处理事件的方式。

##### 详细说

在JavaScript 中，事件流分为三个阶段: 捕获阶段、目标阶段和冒泡阶段。这三个阶段是从外到内，从父节点到子节点，再从子节点到父节点的顺序依次发生。事件流的过程如下:

1.捕获阶段:事件从最外层的节点(文档对象)开始，逐级向下传播，直到达到事件的目标节点。

2.目标阶段: 事件到达目标节点，触发目标节点上的事件处理函数

3.冒泡阶段: 事件从目标节点开始，逐级向上传播，直到达到最外层的节点(文档对象)

##### 拓展答

在事件流中，事件的传播过程可以被停止或取消。在事件处理函数中，可以使用event.stopPropagation0 方法阻止事件的进一步传播，或者使用 event.preventDefault) 方法取消事件的默认行为。





## 精讲：事件循环

### 浏览器的事件循环

JavaScript的任务分为两种：

**·  同步任务：**在主线程上排队执行的任务，只有一个任务执行完毕，才能执行下一个任务

**·  异步任务：**不进入主线程，而是放在任务队列中，若有多个异步任务则需要在任务队列中排队等待，任务队列类似于缓冲区，任务下一步会被移到执行栈然后主线程调用执行栈的任务。



#### 执行栈和任务队列

##### 1）执行栈

执行栈使用的是数据结构中的栈结构，是一个存储函数调用的栈结构，遵循**先进后出**的原则。**它主要负责跟踪所有要执行的代码。**每当一个函数执行完成时，就会从堆栈中弹出(pop) 该执行完成函数；如果有代码需要进去执行的话，就进行 push 操作。以下图为例:



JavaScript在按顺序执行执行栈中的方法时，每次执行一个方法，都会为它生成独有的执行环境(上下文)，当这个方法执行完成后，就会销毁当前的执行环境，并从栈中弹出此方法，然后继续执行下一个方法。



##### 2）任务队列

任务队列使用到的是数据结构中的队列结构，它用来保存异步任务，遵循**先进先出**的原则。**它主要负责将新的任务发送到队列中进行处理。**

JavaScript在执行代码时，会将同步的代码按照顺序排在执行栈中，然后依次执行里面的函数。当遇到异步任务时，就将其放入任务队列中，等待当前执行栈所有同步代码执行完成之后，就会从异步任务队列中取出已完成的异步任务的回调并将其放入执行栈中继续执行，如此循环往复，直到执行完所有任务。

![事件循环.png](https://cdn.nlark.com/yuque/0/2021/png/1500604/1627875726429-621cd37a-ce50-466a-8c87-b677200b43cf.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_5pyI5ZOl55qE6Z2i6K-V6K6t57uD6JCl%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

**在事件驱动的模式下，至少包含了一个执行循环来检测任务队列中是否有新任务。通过不断循环，去取出异步任务的回调来执行，这个过程就是事件循环，每一次循环就是一个事件周期。**

#### 宏任务和微任务

任务队列其实不上一种，根据任务种类的不同，可以分为**微任务 (micro task) 队列**和**宏任务 (macro task)队列**。

**·  宏任务：**script（整体代码）、setTimeout、sentInterval、I/O、UI交互事件、setImmediate（Node.js 环境）

**·  微任务：**Promise、MutationObserver、process.nextTick(Node.js 环境)

Eventloop 在处理宏任务和微任务的逻辑时的顺序如下：

1. JavaScript 引擎首先从宏任务队列中取出第一个任务；
2. ，执行完毕后，再将微任务中的所有任务取出，按照顺序分别全部执行(这里包括不仅指开始执行时队列里的微任务)，如果在这一步过程中产生新的微任务，也需要执行，**也就是说在执行微任务过程中产生的新的微任务并不会推迟到下一个循环中执行，而是在当前的循环中继续执行。**
3. 然后再从宏任务队列中取下一个，执行完毕后，再次将 microtask queue 中的全部取出，循环往复，直到两个 queue 中的任务都取完。

**也是就是说一次 Eventloop 循环会处理一个宏任务和所有这次循环中产生的微任务**。

**总结：**

·  微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。

·  微任务的执行时长会影响当前宏任务的时长。比如一个宏任务在执行过程中，产生了 10 个微任务，执行每个微任务的时间是 10ms，那么执行这 10 微任务的时间就是 100ms，也可以说这 10 个微任务让宏任务的护行时间延长了 100ms.

·  在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行(优先级更高)

**为什么要将任务队列分为微任务和宏任务呢，他们之间的本质区别是什么呢?**

·  微任务：不需要特定的异步线程去执行，没有明确的异步任务去执行，只有回调

·  宏任务：需要特定的异步线程去执行，有明确的异步任务去执行，有回调



### Node.js 的事件循环

#### 概念





## 一、数据类型

### ***1.JavaScript有哪些数据类型，它们的区别？

##### 数据类型：

JavaScript有8种数据类型，分别是 String、Number、Object、Boolean、Undefined、Null、Symbol、BigInt

##### 存放位置：

栈：原始数据类型（String、Number、Undefined、Null、Boolean）

堆：引用数据类型（对象、数组、函数）

##### 区别：

**存放位置不同**

原始数据类型存放在栈（stack）中，占据空间小，大小固定，被频繁引用。

引用数据类型存放在堆（heap）中，占据空间大，大小不固定，如果存放在栈中会影响程序运行的性能。它会在栈中存储一个指针，该指针指向堆中该实体的地址。

### ***2.数据类型检测方式有哪些

1. **typeof检测**

   返回值：对应数据类型的小写字符串 例：Number 数字类型 返回就是 小写的number

2. **instanceof检测**

   返回值：返回值是布尔值（true/false），判断前者是否在后者的[原型对象](https://so.csdn.net/so/search?q=原型对象&spm=1001.2101.3001.7020)上

3. **constructor检测**

    返回值：是构造函数

    注意：它的原型可以被修改

5. **Object.getPrototypeOf() 检测**

6. **Object.prototype.toString.call() 检测**

   

   

### ***3.判断数组的方式有哪些

##### 1.通过Object.prototype.toString.call()做判断

```js
Object.prototype.toString.call(obj).slice(8,-1) === 'Array';
```

##### 2.通过原型链做判断

```js
Obj._proto_ === Array.prototype;
```

##### 3.通过ES6的Array.isArray()做判断

```js
Array.isArray(obj);
```

##### 4.通过instanceof做判断

```js
obj instanceof Array
```

##### 5.通过Array.prototype.isPrototypeOf

```js
Array.prototype.isPrototypeOf(obj)
```

 

### ***4.null和undefined的区别

null和undefined都是基本数据类型，都只有一个值，分别是null和undefined。

null代表的是**空对象**

undefined代表的是**未定义**

一般变量声明了但没有定义的时候会返回undefined，而null一般赋值给一些可能会返回给对象的变量，作为初始化

安全的undefined值：viod 0

在用typeof进行判断时，undefined返回’undefined‘，而null则会返回’object‘

```js
undefined == null // true
undefined === null // false
```

### **5.typeof null 的结果是什么，为什么？

typeof null 的结果为"object”，这是 JavaScript 语言的一个历史遗留问题，在JavaScript 最初的版本中，使用 32 位的值表示一个变量，其中前 3 位用于表示值的类型。000 表示对象，010 表示浮点数，100 表示字符串，110 表示布尔值，和其他的值都被认为是指针。在这种表示法下，null 被解释为一个全零的指针，也就是说它被认为是一个空对象引用，因此 typeof null的结果就是"object"

typeof null 的结果是object

在JavaScript的第一个版本，所有值都存储在32位的单元中，每个单元包含一个小的**类型标签（1-3 bits）**以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：

```js
1.000:object   -当前存储的数据指向一个对象
2.  1:int      -当前存储的数据是一个31位的有符号整数
3.010:double   -当前存储的数据是一个双精度的浮点数
4.100:string   -当前存储的数据指向一个字符串
5.110:boolean  -当前存储的数据是布尔值
```

undefined的值是(-2)30（一个超出整数范围的数字）

null的值是机器码NULL指针（null指针的值全是0）

### ***6.instanceof操作符的实现原理及实现

instanceof 主要判断对象的一个类型

instanceof运算符用来判断构造函数的prototype属性是否在对象原型链中的任何位置

```js
function myInstanceof (left,right){
//获取对象的原型
const proto =  Object.getPrototypeOf(left)
//获取构造函数的prototype对象
const prototype = right.prototype

//判断构造函数的prototype属性是否在对象的原型链上
while(true){
	if(!proto) return false
	if(proto === prototype) return true
	//如果没有找到，就继续在其原型链上找，用Object.getPrototypeof方法来获取指定对象的原型
	proto = Object.getPrototypeOf(proto)

}
```

### ***7.为什么0.1+0.2 !== 0.3，如何让其相等

```js
let n1 = 0.1 , n2 = 0.2
console.log(n1+n2)  //0.30000000000000004
```

如果想要等于0.3， 需要进行转化：

```js
(n1 + n2).toFixed(2) //注意，toFixed为四舍五入
```

**toFixed(num)**方法可以把Number四舍五入为指定小数位数的数字。



对于这种问题了，一个直接的解决方法，就是设置一个误差范围，通常称为”机器精度“，在JavaScript中，这个值通常为2-52。

在ES6中，提供了Number.EPSILON属性，他的值是2-52，只要判断0.1+0.2-0.3是否小于Number.EPSILON，如果小于，就可以判断为0.1+0.2 === 0.3

### *8.如何获取安全的undefined值？

使用void 0 来获取，因为void并不会改变表达式的结果，只是让表达式不返回值。

### *9.typeof NaN 的结果是什么

NaN指”不是一个数字“（not a number），它是一个警戒值（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即”执行数学运算没有成功，这是失败后返回的结果“

```js
typeof NaN; //"number"
```

NaN是一个特殊值，它与自身不相等，是唯一一个非自反的值（自反，reflexive，即x===x不成立）。而NaN !== NaN 为 true。

### **10.isNaN 和 Number.isNaN 函数的区别

函数 isNaN 接收参数后，会尝试将这个参数转化为数值，任何不能转化为数值的值都会返回true，因此非数字值传入时也会返回true，会影响NaN的判断。

函数 Number.isNaN 接收参数会先判断这个参数是否为数值，如果是数值再继续判断是否为NaN，并不会进行数据类型的转化，这种方法对NaN的判断更为准确。

### ***11.== 操作符强制转化规则

对于 **==** 来说，如果对比双方类型**不一样**，就会进行类型转化。

对比流程为：

1. 首先判断两者的类型是否**相同**，相同的话比较两者的大小；

2. 类型不相同的话，就会进行类型转换；

3. 会先判断对比两方是否为 **null** 和 **undefined** ，如果是则返回true；

   ```js
   null == undefined    //true
   ```

   

4. 判断两者的类型是否为 **string** 和 **number** ，是的话将字符串转化为 **number**；

   ```js
   1 == '1'
         ↓
   1 ==  1   //true
   ```

5. 判断其中一方是否为 **boolean** ，是的话会把 **boolean** 转为 **number** ；

   ```js
   '1' == true
          ↓
   '1' == 1
          ↓
    1  == 1   //true
   ```

6. 判断其中一方是否为 **object** ，且另一方为 **string** 、**number** 、**symbol**，如果是，将 object 转换为原始数据类型。

   ```js
   '1' == { name: 'js'}
               ↓
   '1' == '[object object]'
   ```



```flow
st=>start: x == y
cond1=>condition: x和y是否类型相同
op1=>operation: x === y
cond2=>condition: null == undefined
op2=>operation: true
cond3=>condition: string == number
op3=>operation: string 转 number
cond4=>condition: boolean == any
op4=>operation: boolean 转 number
cond5=>condition: object == string or number or symbol
op5=>operation: object 转基本类型
cond6=>condition: 继续判断x和y是否类型相同 
end=>end: false

st->cond1
cond1(yes)->op1
cond1(no,right)->cond2
cond2(yes)->op2
cond2(no,right)->cond3
cond3(yes)->op3
cond3(no,right)->cond4
cond4(yes)->op4
cond4(no,right)->cond5
cond5(yes)->op5->cond6
cond5(no,right)->end



```





### **12.其他值到字符串的转换规则

1. Null 和 Undefined 类型，null 转换为”null"，undefined 转换为“undefined”
2. Boolean 类型，true 转换为 “true” ，false 转换为 “false”
3. Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式
4. Symbol 类型的值直接转换，但只允许显式强制类型转换，使用隐式强制类型转换会产生错误
5. 对普通对象来说，除非自定义的 toString() 方法，否则会调用toString() (Object.prototype.toString()) 来返回内部属性[[Class]] 的值，如"[Object Object]"。如果对象有自己的toString() 方法，字符串化时就会调用该方法并使用其返回值



### **13.其他值到数字值的转换规则

1. Undefined 类型的值转换为NaN
2. Null 类型的值转换为 0 
3. Bollean 类型的值，true 转换为 1 ，false 转换为 0 
4. String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为NaN，空字符串为 0
5. Symbol 类型的值不能转换为数字，会报错
6. 对象（包括数组）会首先转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵守以上规则将其强制转换为数字

为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue ）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换，如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换

如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误





### **14.其他值到布尔类型的值的转换规则

以下这些是假值：

​	undefined、null、fasle、+0、-0、NaN、“ ”

假值的布尔强制转换结果为false。从逻辑上说，假值列表以外的都应该是真值。





### *15.||和&&操作符的返回值

||和&&首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。

​	对于||来说，如果条件判断结果为true就返回第一个操作数的值，如果为false就返回第二个操作数的值。

​	&&则相反，如果条件判断结果为true就返回第二个操作数的值，如果为false就返回第一个操作数的值。

||和&&返回它们其中一个操作数的值，而非条件判断的结果





### ***16.Object.is() 与 比较操作符“===”、“==”的区别

使用双等号（==）进行相等判断时，如果两边类型不一致，则会进行强制类型转换后再进行比较

使用三等号（===）进行相等判断时，如果两边类型不一致，不会进行强制类型转换，直接返回false

使用 Object.is 来进行相等判断时，一般情况下与三等号判断相同，它处理了一些特殊的情况，比如 -0 和 +0不再相等，两个NaN相等





### 17.什么是JavaScript中的包装类型



### **18.JavaScript中如何进行隐式类型转换

首先是**ToPrimitive**方法，这是JavaScript中每个值隐含的自带的方法，用来将值（无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型值，则返回值本身；如果值为对象，其看起来大概是这样：

```js
/**
* @obj 需要转换的对象
* @type 期望的结果类型
*/
ToPrimitive(obj,type)
```

**type** 的值为 **number** 或 **string** 。

1. 当 type 的值为 number 时规则如下：

   调用 obj 的 valueOf 方法，如果为原始值，则返回，否则下一步；

   调用 obj 的 toString 方法，后续同上；

   抛出 Type Error 异常。

2. 当 type 的值为 string 时规则如下：

   调用 obj 的 toString 方法，如果为原始值，则返回，否则下一步；

   调用 obj 的 valueOf 方法，后续同上；

   抛出 Type Error 异常。

可以看出两者主要区别在于调动 **toString** 和 **valueOf** 的先后顺序。默认情况下：

​	如果对象为 **Date** 对象，则 **type** 默认为 **string**；

​	其他情况下，**type** 默认为 **number**。

总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：

```js
var objToNumber = value => Number(value.valueOf().toString())
objToNumber([]) === 0
objToNumber({}) === NaN
```



而JavaScript中的隐式类型转换主要发生在**+、-、*、/** 以及**==、>、<** 这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用 **ToPrimitive** 转换成基本类型，再进行操作。



以下是基本类型的值在不同操作符的情况下隐式转换的规则（对于对象，其会被 **ToPrimitive** 转换成基本类型，所以最终还是要应用基本类型转换规则） ：

1. +操作符   **+** 操作符的两边有至少一个 **string** 类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。

```js
1 +'23'//123
1 + false // 1
1 + Symbol() // Uncaught TypeError: Cannot convert a Symbol value to a number
'1' + false //'1falsefalse + true // 1
```

2. **-、*、/** 操作符NaN也是一个数字

```js
1 * '23' // 23
1 * false // @
1 / 'aa' // NaN
```

3. 对于**==** 操作符
   操作符两边的值都尽量转成 **numbe** :

```js
3 == true // false，3 转为number为3，true转为number为1
'0’== false //true，'0转为number为0，false转为number为0
'0'== 0 //"转为number为0
```

4. 对于**<**和**>** 比较符
   如果两边都是字符串，则比较字母表顺序:

```js
'ca' < 'bd'// false
'a' < 'b' // true
```

​	其他情况下，转换为数字再比较:

```js
'12' < 13 // true1
false > -1 // true
```

以上说的是基本类型的隐式转换，而对象会被 **ToPrimitive** 转换为基本类型再进行转换:

```js
var a = {}
a > 2 //false
```

其对比过程如下：

```js
a.valueof() // ，上面提到过，Torimitive默认type为number，所以先value0f，结果还是个对象，下一步
a.tostring() //“[object object]"，现在是一个字符串了
Number(a.tostring()) // NaN，根据上面< 和 >操作符的规则，要转换成数字
NaN > 2 //false，得出比较结果
```

又比如：

```js
var a = fname:'jack'1
var b = fage: 181
a + b // "[object object][object object]"
```

运算过程如下:

```js
a.valueof() // ，上面提到过，ToPrimitive默认type为number，所以先valueof，结果还是个对象，下一步
a.tostring() // "[object object]"
b.valueof() // 同理
b.tostring() //"[object object]"
a + b // "[object object][object object]"
```





### *19.+ 操作符什么时候用于字符串的拼接?

### 20.为什么会有Biglnt的提案?

### 21.object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别

都是浅拷贝

扩展运算符：

```js
let outObj = {
inObj: {a: 1, b: 2}
}
let newObj = {...outObj}
newObj.inObj.a = 2
console.log(outObj) // {inObj: {a: 2,b: 2}
```

Object.assign():

```js
let outObj = {
inObj: {a: 1, b: 2}
}
let newObj = Object.assign({}, outObj)
newObj.inObj.a = 2
console.log(outobj) // {inobj: {a: 2, b: 2}}
```



深拷贝和浅拷贝是针对引用数据类型（如Object和Array）的两种拷贝方式。浅拷贝只是将原对象的内存地址复制给另一个变量，实际上还是同一个内存地址空间，对任何一个变量修改元素，都是在修改同一个内存地址。而深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。赋值和浅拷贝的区别在于，赋值是将对象在栈中的地址赋给一个新的变量，而浅拷贝是按位拷贝对象，创建一个新对象，但是新对象和原对象共享同一块内存。





## 二、ES6

### ***1.let、const、var的区别

1. **块级作用域**：块作用域由 {  } 包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：

   · 内层变量可能覆盖外层变量

   · 用来计数的循环变量泄露为全局变量

2. **变量提升**：var存在变量提升，const和let不存在变量提升，即在变量只能在声明之后使用，否则会报错。

3. **给全局添加属性**：浏览器的全局对象是windows，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但let和const不会。

4. **重复申明**：var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的变量。const和let不允许重复声明变量。

5. **暂时性死区**：在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称作暂时性死区。使用var声明的变量不存在暂时性死区。

6. **初始值设置**：在变量声明时，var和let可以不用设置初始值。而const声明变量必须设置初始值。

7. **指针指向**：let和const都是ES6新增的用于创建变量的语法。let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。



### **2.const对象的属性可以修改吗

const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据(数值、字符串、布尔值)，其值就保存在变量指向的那个内存地址，因此等同于常量。

但对于引用类型的数据(主要是对象和数组)来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。



### **3.如果new一个箭头函数会怎么样

箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。
new操作符的实现步骤如下

1. 创建一个对象
2. 将构造函数的作用域赋给新对象 (也就是将对象的proto属性指向构造函数的prototype属性)

3. 指向构造函数中的代码，构造函数中的this指向该对象 (也就是为这个对象添加属性和方法)
4. 返回新的对象
   所以，上面的第二、三步，箭头函数都是没有办法执行的。



### ***4.箭头函数与普通函数的区别

1. **箭头函数比普通函数更加简洁**

   · 如果没有参数，就直接写一个空括号即可
   · 如果只有一个参数，可以省去参数的括号
   · 如果有多个参数，用逗号分割
   · 如果函数体的返回值只有一句，可以省略大括号
   · 如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数:

   ```js
   let fn = () => void doesNotReturn();
   ```

2. **箭头函数没有自己的this**

   箭头函数不会创建自己的this，所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变

3. **箭头函数继承来的this指向永远不会改变**

4.  **call()、apply(）、bind()等方法不能改变箭头函数中this的指向**

   ```js
   var id ='Global';
   let fun1 = () => {
   console.log(this.id)
   };
   fun1();//Global
   fun1.call({id:'obj'});//'Global'
   fun1.apply({id:'obj'});//'Global'
   fun1.bind({id:'obj'})();//'Global'
   ```

5. **箭头函数不能作为构造函数使用**

   构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。

6. **箭头函数没有自己的arguments**

   箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。

7. **箭头函数没有prototype**

8. **箭头函数不能用作Generator函数，不能使用yeild关键字**



### **5.箭头函数的this指向哪里

箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于自己的this，它所谓的this是捕获其所在上下文的this 值，作为自己的 this 值，并且由于没有属于自己的this，所以是不会被new调用的，这个所谓的this也不会被改变。

### **10.对rest参数的理解

扩展运算符被用在函数形参上时，**它还可以把一个分离的参数序列整合成一个数组**

 rest运算符可以把函数的多个入参收敛进一个数组里。这一点经常**用于获取函数的多余参数，或者处理函数参数个数不确定的情况**。

### **11.ES6中模板语法与字符串处理

ES6中，字符串更容易拼也更容易读

模板字符串的第一个优势一允许用 **${}** 的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个:
· 在模板字符串中，空格、缩进、换行都会被保留
· 模板字符串完全支持“运算”式的表达式，可以在 **${}** 里完成一些计算

基于第一点，可以在模板字符串里无障碍地直接写 html 代码:

```js
let list =`
	<ul>
	<li>列表项1</li>
	<li>列表项2</li>
	</ul>
`;

console.log(message); // 正确输出，不存在报错
```

基于第二点，可以把一些简单的计算和调用丢进 **${}** 来做:

```js
function add(a, b) {
    const finalString = `${a}+${b} = ${a+b}`
    console.log(finalString)
}
add(1,2) //输出 '1 + 2 = 3'
```

除了模板语法外，ES6中还新增了一系列的字符串方法用于提升开发效率:

​	**存在性判定**: 在过去，当判断一个字符/字符串是否在某字符串中时，只能用 indexof>-1 来做。现在 ES6提供了三个方法: includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。

​		**includes**: 判断字符串与子串的包含关系		

```js
const son = 'haha'
const father = 'xixi haha hehe'
father.includes(son) //true
```

​		**startsWith**: 判断字符串是否以某个/某串字符开头

```js
const father = 'xixi haha hehe'
father.starWith('haha') //false
father.starWith('xixi') //true
```

​		**endsWith**: 判断字符串是否以某个/某串字符结尾

```js
const father = 'xixi haha hehe'
father.endWith('hehe') //true
```

​	**自动重复**: 可以使用 repeat 方法来使同一个字符串输出多次 (被连续复制多次)

```js
const sourceCode = 'repeat for 3 times;'
const repeated = sourceCode.repeat(3)
console.log(repeated) // repeat for 3 times;repeat for 3 times;repeat for 3 times;
```



## 三、JavaScript基础



### ***1.new操作符的实现原理

**new操作符的执行过程**
(1) 首先创建了一个新的空对象,设置原型，将对象的原型设置为函数的 prototype 对象。
(2) 让函数的this指向这个对象(this = Object.create(Constructor.prototypr)）
(3) 执行构造函数的代码，并将属性和方法添加到该空对象中
(4) 判新函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象

```js
function myNew(Constructor,...args){
    //新建一个空对象，对象的原型为构造函数的prototype对象
    let obj = Object.create(Constructor.prototype)
    //将构造函数的this指向新建对象，并执行构造函数的代码
    let result = Constructor.apply(obj,args)\
    //如果构造函数有显式返回一个对象，则返回该对象，否则返回空对象
    return (typeof result === 'object' && result !== null) ? result :obj
}

```

使用myNew 函数创建对象的方式与使用 new 操作符相同， 例如：

```js
function Person(name,age){
    this.name = name;
    this.age = age;
}
let john = myNew(Person,'john',30)
console.log(john); // {name: 'john', age: 30}
```



### **2.map和Object的区别

|          | Map                                                          | Object                                                       |
| :------: | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 意外的键 | Map默认情况不包含任何键，只包含显式插入的键                  | Object 有一个原型,原型链上的键名有可能和自己在对象上的设置的键名产生冲突 |
| 键的类型 | Map的键可以是任意值，包括函数、对象或任意基本类型            | Object 的键必须是 String 或是Symbol                          |
| 键的顺序 | Map 中的 key 是有序的。因此，当迭代的时候，Map 对象以插入的顺序返回键值 | Object 的键是无序的                                          |
|   Size   | Map 的键值对个数可以轻易地通过size属性获取                   | Object 的键值对个数只能手动计算                              |
|   迭代   | Map 是 iterable 的，所以可以直接被迭代                       | 选代object需要以某种方式获取它的键然后才能迭代               |
|   性能   | 在频繁增删键值对的场景下表现更好                             | 在频繁添加和删除键值对的场景下未作出优化                     |



### *3.map和weakMap的区别

### 4.JavaScript有哪些内置的对象

### *5.常用的正则表达式有哪些

### *6.对JSON的理解

### **7.JavaScript脚本延迟加载的方式有哪些

延迟加载就是等页面加载完成之后再加载 JavaScript 文件。js 延迟加载有助于提高页面加载速度。

一般有以下几种方式：

1. **defer 属性**：给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。
2. **async 属性**：给js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。
3. **动态创建 DOM 方式**：动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 is 脚本。
4. **使用 setTimeout 延迟方法**: 设置一个定时器来延迟加载is脚本文件
5. **让 JS 最后加载**：将js 脚本放在文档的底部，来使js脚本尽可能的在最后来加载执行



### **8.JavaScript类数组对象的定义

一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。

常见的类数组转换为数组的方法有这样几种:

1. 通过 call 调用数组的 slice 万法来实现转换

   ```js
   Array.prototype.slice.call(arrayLike);
   ```

2.  通过 call 调用数组的 splice 方法来实现转换

   ```js
   Array.prototype.splice.call(arrayLike,0);
   ```

3. 通过 apply 调用数组的 concat 万法来实现转换

   ```js
   Array.prototype.concat.apply([],arrayLike);
   ```

4. 通过 Array.from 方法来实现转换

   ```js
   Array.from(arrayLike);
   ```

   

### ***9.数组有哪些原生方法

1. 数组和字符串的转换方法: toString()、toLocalString()、join() ，其中 join() 方法可以指定转换为字符串时的分隔符。
2. 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。
3. 数组首部操作的方法 shift() 和 unshift ()重排序的方法reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。
4. 数组连接的方法 concat()，返回的是拼接好的数组，不影响原数组。
5. 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。
6. 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexof() 和 lastlndexOf() 选代方法every()、some()、filter()、map()和 forEach()方法。
7. 数组归并方法 reduce() 和 reduceRight() 方法



### *10.Unicode、UFT-8、UFT-16、UFT-32的区别

### *11.常见的位运算符有哪些？其计算规则是？

### **12.为什么函数的arguments参数是类数组而不是数组？如何遍历类数组

**arguments** 是一个对象，它的属性是从 0 开始依次递增的数字，还有 callee 和 length 等属性，与数组相似；但是它却没有数组常见的方法属性，如 forEach ，reduce 等，所以叫它们类数组。

要遍历类数组，有三个方法:

1. 将数组的方法应用到类数组上，这时候就可以使用 call 和 apply 方法，如:

   ```js
   function foo(){
   	Array.prototype.forEach.call(arguments,a => console.log(a))
   }
   ```

2. 使用Array.from方法将类数组转化成数组：

   ```js
   function foo(){
       const arrArgs = Array.from(arguments)
       arrArgs.forEach(a => console.log(a))
   }
   ```

3. 使用展开运算符将类数组转化成数组

   ```js
   function foo(){
       const arrArgs = [...argument]
       arrArgs.forEach(a => console.log(a))
   }
   ```

   





### ***13.什么是DOM和BOM

DOM 指的是**文档对象模型**，它指的是把**文档当做一个对象**，这个对象主要定义了处理网页内容的方法和接口

BOM 指的是**浏览器对象模型**，它指的是把**浏览器当做一个对象**来对待，这个对象主要**定义了与浏览器进行交互的方法和接口**。

BOM的核心是 window，而 window 对象具有双重角色，它既是通过s 访问浏览器窗口的人接口，又是一个 Global(全局) 对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象



### ***14.对于类数组对象的理解，如何转化为数组

一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但不能调用数组的方法。常见的类数组对象有 argument 和DOM 方法的返回结果，函数参数也可以被看作类数组对象，因为它含有 length 属性值，代表可接收的参数个数。

常见的类数组转换为数组的方法有：

1. 通过 call 调用数组的 slice 方法来实现 转换

   ```js
   Array.prototype.slice.call(arrayLike)
   ```

2. 通过 call 调用数组的 splice 方法来实现转换

   ```js
   Array.prototype.splice.call(arrayLike,0)
   ```

3. 通过apply 调用数组的 concat 方法来实现转换

   ```js
   Array.prototype.concat.apply([],arrayLike)
   ```

4. 通过 Array.from 方法实现转换

   ```js
   Array.from(arrayLike)
   ```







### ***16.对于AJAX的理解，实现一个AJAX请求

AJAX 是Asynchronous JavaScript and XML 的缩写，**指的是通过 JavaScript 的 异步通信，从服务器获取 XML文档，从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页**。

创建AJAX请求的步骤：

1. **创建一个XMLHttpRequest 对象**
2. 在这个对象上**使用 open 方法创建一个 HTTP 请求**，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。
3. 在发起请求前，可以为这个对象**添加一些信息和监听函数**。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发 onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新
4. 当对象的属性和监听函教设置完成后，最后**调用 send 方法来向服务器发起请求**，可以传入参数作为发送的数据体。

```js
const SERVER_URL = "/server";
let xhr = new XMLHttpRequest();
//创建 Http 请求
xhr.open("GET", url, true);
//设置状态监听函数
xhr.onreadystatechange = function() {
    if(this.readyState !== 4) return;
    //当请求成功时
    if (this.status === 200) {
        handle(this.response);
    } else {
        console.error(this.statusText);
    }
};
//设置请求失败时的监听函数
xhr.onerror = function(){
    console.error(this.statusText);
};
//设置请求头信息
xhr.responeType = "json";
xhr.setRequestHeader("Accept", "application/json");
//发送 Http 请求
xhr.send(null);
```

使用Promise封装AJAX

```js
//promise 封装实现
function getJSON(url) {
    // 创建一个promise 对象
    let promise = new Promise(function(resolve,reject){
        let xhr = new XMLHttpRequest();
        //新建一个 http 请求
        xhr.open("GET",url,true);
        //设置状态的监听函数
        xhr.onreadystatechange = function(){
            if (this.readyState !== 4) return;
            //当请求成功或失败时，改变 promise 的状态
            if(this.status === 200) {
                resolve(this.response);
            } else {
                reject(new Error(this.statusText));
            }
        };
        //设置错误监听函数
        xhr.onerror = function(){
            reject(new Error(this.statusText));
        };
        //设置响应数据类型
        xhr.responseType = "json";
        //设置请求头信息
  		xhr.serRequestHeader("Accept","application/json");
        //发送 http 请求
        xhr.send(null);
    });
    return promise
}
```



### ***17.JavaScript为什么要进行变量提升，它导致了什么问题

1. **提高性能**

   解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间

2. **容错性更好**

   声明提升还可以提高js代码的容错性，使一些不规范的代码也可以正常执行

问题：会导致一些局部变量提升为全局变量，在函数结束之后不会被销毁，影响结果



### **18.ES6模块与CommonJS模块有什么异同

ES6 Module和CommonJs模块的区别:

1. CommonJS是对模块的浅拷贝，ES6 Module是对模块的引用，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const;
2. import的接口是read-only (只读状态)，不能修改其变量值。即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值(改变指针指向)，但是对ES6 Module赋值会编译报错

ES6 Module和CommonJs模块的共同点:

​	CommonJS和ES6 Module都可以对引入的对象进行赋值，即对对象内部属性的值进行改变



### **22.如何判断一个对象是否属于某个类

1. 第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。
2. 第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。
3. 第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断

### **25.for...in和for...of的区别

for..of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for...in的区别如下

1. for...of 遍历获取的是对象的键值，for...in 获取的是对象的键名；
2. fo.in会遍历对象的整个原型链，性能非常差不推荐使用，而 for ... of 只遍历当前对象不会遍历原型链；
3. 对于数组的遍历，for...in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for...of 只返回数组的下标对应的属性值；

**总结**：for...in 循环主要是为了遍历对象而生，不适用于遍历数组；for...of 循环可以用来遍历数组、类数组对象、字符串、Set、Map 以及 Generator 对象







### **28.数组的遍历方法有哪些

| 方法                      | 是否改变原数组 | 特点                                                         |
| ------------------------- | -------------- | ------------------------------------------------------------ |
| forEach()                 | 否             | 数组方法，不改变原数组，没有返回值                           |
| map()                     | 否             | 数组方法，不改变原数组，有返回值，可链式调用                 |
| filter()                  | 否             | 数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用 |
| for...of                  | 否             | for...of遍历具有lterator选代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环 |
| every() 和 some()         | 否             | 数组方法，some() 只要有一个是true，便返回true; 而 every() 只要有一个是false，便返回false. |
| find() 和 findIndex()     | 否             | 数组方法，find() 返回的是第一个符合条件的值；findIndex() 返回的是第一个返回条件的值的索引值 |
| reduce() 和 reduceRIght() | 否             | 数组方法，reduce() 对数组正序操作；reduceRight() 对数组逆序操作 |





## 四、原型与原型链

一个对象，有一个显示原型和(`prototype`)一个隐式原型（`__ proto __`)，隐式原型指向构造函数的原型对象（`prototype`），构造函数的原型对象又有自己的(` __ proto __`)

### ***1.对原型和原型链的理解

在JavaScript中是使用构造函数来新建一个对象的，每个构造函数内部都有一个prototype属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。

当使用构造函数新建一个对象后，在这个对象内部将包含一个指针，这个指针指向构造函数的prototype 属性对应的值，在ES5中这个指针被称为**对象的原型**，ES5中新增了一个Object.getPrototypeOf()  方法，可以通过这个方法获取对象的原型

##### 概念

原型链是JavaScript中实现继承的一种机制。每个实例对象（object）都有一个私有属性（__ proto __ __) 指向它的构造函数的原型对象（prototype）。该原型对象也有自己的原型对象（__ __ proto __）,层层向上直到一个对象的原型对象为null。这样就形成了一个原型链。

##### 拓展

如果在当前对象中查找某个属性或方法时，当前对象不存在该属性或方法，JavaScript引擎会沿着原型链向上查找，直到找到该属性或方法为止，或者查找到原型链的顶端。

##### 缺点

在原型链上查找属性比较耗时，对性能有副作用，这在**性能要求苛刻(一般情况基本无影响)**的情况下很重要。另外，**试图访问不存在的属性时会遍历整个原型链**(这点也很重要，需要记住)。

![img](https://img-blog.csdnimg.cn/20200220221933279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pZUVpYRg==,size_16,color_FFFFFF,t_70)

##### 案例理解

用 **constructor** 的时候，产生一个实例

**实例.__ proto __** 指向**构造函数的原型对象**，也就是**构造函数.prototype**

**构造函数.prototype.constructor** 指向构造函数本身

然后构造函数.prototype.__ proto __ 指向Object的实例对象

也就是说**构造函数.prototype.__ proto __** 指向Object的原型对象

然后再从 实例.Object.__ proto __ 指向Object.prototype 的过程，都是原型上的__ proto __ 然后直接往上指的底边就形成一条原型链，最终指向null

Object.prototype.__ proto __ ===null

### **2.原型修改、重写

```js
//1、创建一个构造函数
function Person(name) {
    this.name = name
}
//2、修改原型,在原型上添加一个方法getName
Person.prototype.getName = function(){
	console.log(this.name);
}
 //3、创建一个实例对象
const p = new Person('hello')
//4、修改原型后，比较构造函数的显示原型和实例对象的隐式原型是否相等
console.log(p.__proto__ === Person.prototype) //true
// 5、修改原型后，比较实例对象的隐式原型和实例对象的构造函数（通过p.constructor获取）的显示原型是否相等
console.log(p.__proto__ === p.constructor.prototype) //true
//重写原型
Person.prototype = {
    getName: function() {}
}
const p = new Person('hello')
console.log(p.__proto__ === Person.prototype) //true
console.log(p.__proto === p.constructor.prototype) //false
```



可以看到修改原型的时候p的构造函数不是指向Person了，因为直接给Person的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数Object,所以这时候 p.constructor === Object ，而不是 p.constructor === Person .要想成立，就要用constructor指回来:

```js
Person.prototype = {
    getName = function() {}
}
var p = new Person('hello')
p.constructor = Person
console.log(p.__proto__ === Person.prototype) //true
console.log(p.__proto === p.constructor.prototype) //true
```



### ***3.原型链指向

```js
p.__proto__ //Person.prototype
Person.prototype.__proto__ //Object.prototype
p.__proto__.__proto__ //Object.prototype
p.__proto__.constructor.prototype.__proto__//Object.prototype
Person.prototype.constructor.prototypr.__proto__ //Object.prototype
p1.__proto__.constructor //Person
Person.prototype.constructor //Person
```







## 五、执行上下文/作用域链/闭包

### ***1.对闭包的理解

##### 概念

闭包是指**有权访问另一个函数作用域中变量的函数，即一个定义在函数内部的函数，或者说闭包是个内嵌函数。**



创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量

优点是私有化数据，在私有化数据的基础上保持数据，缺点是使用用不恰当会导致内存泄漏，在不需要用到的时候及时把变量置为null

**详细来说**

闭包可以将变量和函数私有化，从而避免命名冲突和变量污染。当函数执行完毕后，该函数内部定义的变量和函数仍然存在于内存中，不会被自动回收，因此可以被其他函数继续访问和使用。这个机制称为闭包
闭包的原理是在内存中创建一个包含函数和变量的环境，当函数返回后，该环境仍然存在于内存中，因此可以被其他函数访问和使用。闭包中的变量和函数可以被多次调用和修改，因此可以实现许多高级功能。

**闭包的使用场景**

闭包的应用非常广泛，特别是在异步编程和模块化开发中。以下是一些常见的使用场景：

1. 保存变量状态和私有化变量和函数
2. 用于事件处理和回调函数
3. 用于封装类和模块
4. 用于实现柯里化和函数式编程
5. 用于解决循环中异步问题
6. 用于实现缓存和记忆化等功能

##### Vue

Vue也有使用到闭包的地方，比如在Vue的组件定义中，会用到data函数来返回一个对象，这个函数就是一个闭包，在组件实例化过程中，每个实例都会得到一个独立的数据对象。

由于Vue是响应式框架，会自动处理视图的更新，而这个过程中也会用到闭包。比如，在 Vue 中，会为每个组件创建一个 Watcher 对象来监听数据的变化，这个 Watcher 对象就是闭包，它持有了组件实例、渲染函数以及需要监听的数据，从而实现了自动更新视图的功能。

##### 注意事项

需要注意的是，闭包会占用内存并且容易造成内存泄漏，因此在使用闭包时需要注意内存管理和性能优化等问题。

##### 闭包一定会造成内存泄露吗

不是所有闭包都会造成内存泄漏，只有在不正确使用闭包的情况下才会发生内存泄漏。

当一个函数返回一个内部函数，而该内部函数持有外部函数的变量时，就会形成闭包。如果该内部函数在外部函数执行结束后仍然存在，那么它会一直持有外部函数的变量，导致这些变量无法被垃圾回收器回收，从而造成内存泄漏。
例如，以下代码就存在内存泄漏的风险:

```js
function outer(){
    var count = 0
    return function inner(){
        count++
        console.log(count)
    }
}
var f = outer()
f() //1f();//2
```

在这个例子中，outer()函数返回一个内部函数 inner()，而inner() 持有了 outerl() 函数的变量 count,如果 inner()函数一直存在，count 变量就无法被释放，从而导致内存泄漏。
为了避免内存泄漏，我们可以手动解除闭包，即将对内部函数的引用删除。例如，可以将内部函数赋值为null，或者将外部函数返回的引用赋值为 null。
总之，闭包不一定会造成内存泄漏，只有在不正确使用闭包的情况下才会发生内存泄漏。在编写代码时需要注意正确使用闭包并避免内存泄漏的问题。

##### 使用哪些方式可以防止闭包引起的内存泄漏

以下是一些可以防止闭包引起内存泄漏的方式：

1. 避免创建不必要的闭包：如果闭包中包合的变量在函数执行完后不再需要使用，可以避免创建闭包，从而避免内存泄漏的问题。
2. 及时释放闭包:：在使用闭包时，需要在不需要时及时释放闭包，可以使用变量赋值为 null 或者手动解除对闭包的引用等方式来释放闭包。
3. 使用横块模式：在模块模式中，可以使用立即执行函数(IIFE)来创建一个私有作用域，从而避免闭包中的变量被外部访问，避免了内存泄漏的问题。
4. 避免循环引用：如果闭包中引用了 DOM 元素或其他对象，需要确保在不需要时及时释放这些对象，避免循环引用造成内存泄漏的问题

总之，防止闭包引起内存泄漏需要结合具体的情况进行综合考虑和处理，同时也需要注意代码的可读性和可维护性。





### ***2.对作用域作用域链的理解

#### 1.作用域

##### 概念

在JavaScript中，作用域（scope）是指在程序中定义变量的可见范围，它规定了变量的可见性和生命周期。

##### 详细举例

JavaScript中的作用域分为全局作用域和函数作用域。它们之间存在嵌套关系，也就是所谓的作用域链。

**全局作用域**是指程序中定义在最外层的变量，在代码中任何地方都可以访问的变量，它们在整个应用程序中都是可见的。

**函数作用域**是指在函数内部定义的变量，它们只能在该函数内部访问，函数外部无法访问这些变量。

JavaScript中还是一个特殊的作用域，即块级作用域。在 ES6 之前，JavaScript 中没有块级作用域，只有全局作用域和函数作用域。在 ES6 中，使用 let 和 const 关键字可以创建块级作用域。块级作用域是指在代码块(通常是指用花括号包含的语句集合)中定义的变量，它们只能在该代码块内部访问，代码块外部无法访问这些变量

##### 总结

在JavaScript 中，变量的作用域是由它们在代码中声明的位置所决定的。当程序执行时，JavaScript引擎会根据变量声明的位置来确定变量的作用域。通常，let和const变量在声明的位置下方的代码都可以访问该变量，而在声明位置上方的代码则无法访问该变量。

#### 2.作用域链

**当访问一个变量时，代码解释器会首先在当前作用域查找，如果没找到，就去父级作用域去查找，直到找到该变量或者不存在父级作用域中，依次向上级作用域查找，直到访问到window对象就被终止，这样的链路就是作用域链。**



作用域链的作用是**保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。**



作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象(也就是全局对象)始终是作用域链的最后一个对象。

当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。

### ***3.对执行上下文的理解

##### 1.执行上下文类型

###### （1）全局执行上下文

任何不在函数内部的都是全局执行上下文，他首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文

###### （2）函数执行上下文

当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个

###### （3）**eval** 函数执行上下文

##### 2.执行上下文栈

JavaScrip引擎使用执行上下文栈来管理执行上下文

当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函教调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。

##### 3.创建执行上下文

创建执行上下文有两个阶段：**创建阶段**和**执行阶段**

###### 1）创建阶段

1. this绑定

   在全局执行上下文中，this指向全局对象（window对象）

   在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么this会被设置成那个对象，否则this的值被设置为全局对象或者undefined

2. 创建词法环境组件

   词法环境是一种有**标识符一一变量映射**的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。
   词法环境的内部有两个组件：**加粗样式**:环境记录器:用来储存变量个函数声明的实际位置**外部环境的引用**：可以访问父级作用域

3. 创建变量环境组件

   变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。

###### 2）执行阶段

此阶段会完成对变量的分配，最后执行完代码。

**简单来说执行上下文就是指：**

在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。

在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。

全局上下文: 变量定义，函数声明

函数上下文: 变量定义，函数声明，this ，arguments









## 六、this/call/apply/bind

### ***1.对this对象的理解

this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。

1. 第一种是**函数调用模式**，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象 

2. 第二种是**方法调用模式**，如果一个函数作为一个对象的方法来调用时，this 指向这个对象

3. 第三种是**构造器调用模式**，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。

4. 第四种是 **apply、 call 和 bind 调用模式**，这三个方法都可以显示的指定调用函数的 this 指向。

   其中apply 方法接收两个参数: 一个是 this 绑定的对象，一个是参数数组。

   call 方法接收的参数，第一个是 this绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call()方法时，传递给函数的参教必须逐个列举出来。

   bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this指向除了使用 new 时会被改变，其他情况下都不会改变。

这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式然后是函数调用模式。



### ***2.call()、apply()、bind()的区别

1. **call、apply、bind相同点：** 都是改变this的指向，传入的第一个参数都是绑定this的指向，在非严格模式中，如果第一个参数是 null 或者 undefined，会把全局对象(浏览器是window) 作为this的值，要注意的是在严格模式中，null 就是 null，undefined 就是 undefined
2. **call和apply唯一的区别是：** call传入的是参数列表，apply传入的是数组，也可以是类数组
3. **bind和call、apply的区别：** bind返回的是一个改变了this指向的函数，便于稍后调用，不像call和apply会立即调用; bind和call很像，传入的也是参数列表，但是可以多次传入，不需要像call，一次传入

### ***3.实现call、apply、bind函数

##### 1.call 函数的实现步骤

·   判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。

·   判断传入上下文对象是否存在，如果不存在，则设置为 window。

·   处理传入的参数，截取第一个参数后的所有参数。

·   将函数作为上下文对象的一个属性。

·   使用上下文对象来调用这入方法，并保存返回结果。

·   删除刚才新增的属性。

·   返回结果

```js
Function.prototype.myCall = function(context){
    //判断调用对象
    if (typeof this !== "function"){
        console.error("type error");
    }
    //获取参数
    let args = [...arguments].slice(1),
        result = null;
    //判断context 是否传入，如果未传入则设置为 window
    context = context || window;
    //将调用函数设为对象的方法
    context.fn = this;
    //调用函数
    result = context.fn(...args)
    //将属性删除
    delete context.fn;
    return result;
};
```





##### 2.apply 函数的实现步骤

·   判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。

·   判断传入上下文对象是否存在，如果不存在，则设置为 window。

·   将函数作为上下文对象的一个属性。

·   判断参数值是否传入

·   使用上下文对象来调用这入方法，并保存返回结果。

·   删除刚才新增的属性。

·   返回结果

```js
Function.prototype.myApply = fuction(context){
    //判断调用对象是否为函数
    if(typeof this !== "function") {
        throw new TypeError("Error");
    }
    let result = null;
    //判断 context 是否存在，如果未传入则为window
    constext = context || window;
    //将函数设为对象的方法
    context.fn = this;
    //调用方法
    if(argument[1]) {
        result = context.fn(...argument[1]);
    } else {
        result = context.fn()
    }
    //将属性删除
    delete context.fn;
    return result;
};
```





##### 3.bind 函数的实现步骤

·   判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。

·   保存当前函数的引用，获取其余传入参数值。

·  创建一个函数返回

·   函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的this 给 apply 调用，其余情况都传入指定的上下文对象。

```js
Function.prototype.myBind = function(context){
	//判断调用对象是否为函数
	if(typeof this !== "function"){
        throw new TypeError("Error");
    }
    //获取参数
    var args = [...arguments].slice(1),
        fn =this;
    return function fn() {
        //根据调用方式，传入不同绑定值
        return fn.apply(
        this instanceof Fn ? this : context,
        args.concat(...arguments)
        );
    };
};
```















## 七、异步编程

### **1.异步编程的实现方式

JavaScript中的异步机制可以分为以下几种：

​	·  **回调函数** 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。

​	·  **Promise** 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。

​	·  **generator** 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。

​	·  **async函数** 的方式，async函数是 generator 和 promise 实现的一人自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并目这个函数可以自动执行

### **2.setTimeout、Promise、Async/Await的区别

1. setTimeout

   setTimeout是一个JS函数，它可以在指定的时间后执行一段代码。

   ```js
   console.log('script start') //1.打印script start
   setTimeout(function(){
       console.log('settimeout') //4.settimeout
   })//2.调用setTimeout 函数，并定义其完成后执行的回调函数
   console.log('script end') //3.打印 script end
   //输出顺序：script start ->script end ->settimeout 
   ```

   

2. Promise

   Promise本身是**同步的立即执行函数**，当在executor中执行resolve或者reject的时候，此时是异步操作，会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。

   Promise是一种异步编程的解决方案，它可以避免回调地狱，使得异步代码更加优雅和易于维护.

   ```js
   console.log('script start')
   let peomise1 = new Promise(function(resolve,project){
       console.log('promise1')
       resolve()
       console.log('promise1 end')
   }).then(function(){
       console.log('promise2')
   })
   setTimeout(function(){
       console.log('settimeout')
   })
   console.log('script end')
   //输出顺序：script start ->promise1->promise1 end->script end -> promise2->settimeout
   ```

   当JS主线程执行到Promise对象时:

   ·  promise1.then0 的回调就是一个 task

   ·  promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue（微任务队列）

   ·  promise1 是 pending:这个 task 就会放入 事件循环的未来的某个能下一个回合的 microtask queue 中

   ·  setTimeout 的回调也是个 task，它会被放入 macrotask queue 即使是 0ms 的情况

3. async / await

   ```js
     async function async1() {
         console.log('async1 start')
         await async2()
         console.log('async1 end');
     }
     async function async2() {
         console.log('async2')
     }
     console.log('script start')
     async1()
     console.log('script end')
   //执行顺序：script start -> async1 start ->async2 -> script end -> async1 end
   ```

   async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。

   await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果 (Promise对象)之
   后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。

### ***3.对Promise的理解

**Promise是异步编程的一种解决方案，它是一个对象**，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。

所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件(通常是一个异步操作)的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的AP1，各种异步操作都可以用同样的方法进行处理。

ES6之后引入，用于实现异步编程的特殊对象；衍生开来，ES7后被用于实现 async - await 语法

在 promise 之前，异步操作通常通过注册 **callback 回调方式**处理异步结果，很容易带来回调地狱问题，最终造成代码结构非常不清晰，不直观，维护成本较高(**回调地狱**)

1. Promise的实例有三个状态

   ·  Pending（进行中）

   ·  Resolved（已完成）

   ·  Rejected（已拒绝）

   当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved，没有完成失败了就变成了Rejected

2. Promise的实例有两个过程

   ·  pending -> fulfilled : Resolved (已完成)

   ·  pending -> rejected: Rejected (已拒绝）

   注意：一旦从进行状态变成为其他状态就永远不能更改状态了

**Promise的特点：**

·  对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，pending (进行中)、 fulfilled (已成功)、 rejected (已失败) 。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“**承诺**”。

·  一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能: 从 pending 变为 fulfilled，从 pending 变为 rejected 。这时就称为 resolved (已定型)。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件(event) 完全不同，事件的特点是: 如果你错过了它，再去监听是得不到结果的。

**Promise的缺点：**

·  无法取消Promise，一旦新建它就会立即执行，无法中途取消。

·  如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。

·  当处于pending状态时，无法得知目前进展到哪一个阶段 (刚刚开始还是即将完成)。

**总结：**

Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个Promise 实例有三种状态，分别是pending、resolved 和rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。



### ***4.Promsie的基本用法

##### （1）创建Promise对象

Promise对象代表一个异步操作，有三种状态: pending (进行中)、fulfilled (已成功) 和rejected (已失败)

Promise构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject 。

```js
const promise = new Promise(function(resolve,reject){
    //...some code
    if(/*异步操作成功*/){
        resolve(value);
    } else {
        reject(error);
    }
});
```

一般情况下都会使用 new Promise（）来创建promise对象，但是也可以使用 promise.resolve 和 promise.reject 这两个方法

##### （2）Promise方法

Promise有五个常用的方法: then()、catch()、all()、race()、finally。下面就来看一下这些方法

**1.then()**

当Promise执行的内容符合成功条件时，调用 resolve 函数，失败就调用 reject 函数。Promise创建完了，那该如何调用呢?

```js
promise.then(function(value){
	//success
},function(error){
	//failure
})
```

then 方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为 resolved 时调用，第二个回调函数是Promise对象的状态变为 rejected 时调用。其中第二个参数可以省略。

then 方法返回的是一个新的Promise实例(不是原来那个Promise实例) 。因此可以采用链式写法，即 then 方法后面再调用另一个then方法。

**2.catch()**

Promise对象除了有then方法，还有一个catch方法，该方法相当于 then 方法的第二个参数，指 reject 的回调函数。不过 catch 方法还有一个作用，就是在执行 resolve 回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入 catch 方法中。

**3.all()**

all 方法可以完成并行任务，它接收一个数组，数组的每一项都是一个 promise 对象。当数组中所有的 promise 的状态都达到 resolved 的时候，all 方法的状态就会变成 resolved ，如果有一个状态变成了 rejected 那么 all 方法的状态就会变成 rejected。

调用 all 方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每个promise对象 resolve 执行时的值

**4.race()**

race 方法和 all 一样，接受的参数是一个每项都是 promise 的数组，但是与 all 不同的是，当最先执行完的事件执行完之后，就直接返回该 promise 对象的值。如果第一个 promise 对象状态变成 resolved ，那自身的状态变成了 resolved ;反之第一个 promise 变成 rejected ，那自身状态就会变成 rejected 。

**5.finally()**

finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是ES2018 引入标准的。

```js
promise
.then(res => {...})
.catch(error => {...})
.finally(() => {...})
```

上面代码中，不管 promise 最后的状态，在执行完 then 或 catch 指定的回调函数以后，都会执行 finally 方法指定的回调函数。

finally 方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是 fulfilled 还是 rejected 。这表明， finally 方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 finally 本质上是 then 方法的特例



### **5.Promise解决了什么问题

在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求那么需要如下编写代码：

```js
let fs = require('fs')
fs.readFile('./a/txt','utf8',function(err,data){ fs.readFild('./a/txt','utf8',function(err,data){        fs.readFild('./a/txt','utf8',function(err,data){
            console.log(data)
        })
    })
})
```

上面的代码有如下缺点：

​	·   后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。

​	·  如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。

Promise 出现之后，代码变成这样：

```js
let fs = require('fs')
function read(url){
    return new Promise((resolve,reject)=>{
        fs.readFile(url,'utf8',function(err,data){
            error && reject(error)
            resolve(data)
        })
    })
}
read('./a.txt').then(data => {
    return read(data)
}).then(data => {
    return read(data)
}).then(data => {
    console.log(data)
})
```

这样代码看起来就简洁了很多，解决了地域回调的问题。

### **6.Promise.all 和 Promise.race 的区别和使用场景

**(1) Promise.all**

Promise.all 可以将多个 promise 实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是**一个结果数组**，而失败的时候则返回**最先被reject失败状态的值**。

Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空

需要注意，Promise.al[获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决

(2) Promise.race

顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1,p2,p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决

### ***7.对async/await 的理解

async/await其实是 Generator 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解，**async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。**当然语法上强制规定await只能出现在asnyc函数中。

async 函数返回的是一个 Promise 对象。async 函数 (包含函数语句、函数表达式、Lambda表达式)会返回一 个Promise 对象，如果在函数中 return 一个直接量,async 会把这个直接量通过 Promise.resolve()封装成 Promise 对象。

async函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回的情况下，当然应该用原来的方式: then() 链来处理这个 Promise 对象。

那如果 async 函数没有返回值，又该如何? 很容易想到，它会返 Promise.resolve(undefined)

联想一下 Promise 的特点 ——无等待，所以在没有 await 的情下执行 async 函数，它会立即执行，返回 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。

**注意:** Promise.resolve(x) 可以看作是 new Promise(resolve => resolve(x)) 的简写,可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。

### **8.await到底在等啥

**await 在等待什么呢?**一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值(换句话说，就是没有特殊限定)。

因为 async 函数返回一个 Promise 对象，所以await 可以用于等待一个async 函数的返回值——这也可以说是await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。



await 表达式的运算结果取决于它等的是什么。

​	·  如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西

​	·  如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。







### **9.async/await 的优势

单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了(很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它)。





### **10.async/await 对比Promise的优势

·  代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调用也会带来额外的阅读负担

·  Promise传递中间值非常麻烦，而async/await几乎是同步的写法，非常优雅

·  错误处理友好，async/await可以用成熟的try/catch，Promise的错误捕获非常冗余

·  调试友好，Promise的调试很差，由于没有代码块，你不能在一个返回表达式的箭头函数中设置断点，如果你在一个.then代码块中使用调试器的步进(step-over)功能，调试器并不会进入后续的.then代码块，因为调试器只能跟踪同步代码的每一步。













## 八、面向对象

### ***1.对象创建的方式有哪些

一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种:

##### (1)   工厂模式

工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系

##### (2)   构造函数模式

js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的

##### (3)   **原型模式**

因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。

##### (4)   **组合使用构造函数模式和原型模式**

这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。

##### (5)   **动态原型模式**

这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合楼式进行了封装

##### (6)   **寄生构造函数模式**

这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。



### ***2.对象继承的方式有哪些

##### (1)   原型链继承

这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。

##### (2)   借用构造函数的方式

这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。

##### (3)   **组合继承**

组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函教的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。

##### (4)   原型式继承

原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create（) 方法就是原型式继承的实现。缺点与原型链方式相同。

##### (5)  寄生式继承

寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。

##### (6)   寄生式组合继承

组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。



## 九、垃圾回收机制与内存泄漏

### ***1.浏览器的垃圾回收机制

##### (1) 垃圾回收的概念

**垃圾回收:** JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。



**回收机制:**

​	·   Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。

​	·   JavaScript中存在两种变量:局部变量和全局变量。全局变量的生命周期会持续要页面卸载，而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。

​	·   不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。



##### (2) 垃圾回收的方式

浏览器通常使用的垃圾回收方法有两种: 标记清除，引用计数
1) **标记清除**
·   标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为"进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。

·   垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。



1) **引用计数**
·   另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这人变量已经没有价值，因此，在垃机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。

·   这种方法会引起循环引用的问题: 例如: obj1 和obj2 通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两人对象都离开作用域，函数执行结束， obj1 和 obj2 还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。

##### (3)减少垃圾回收

虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。

·   **对数组进行优化**：在清空一个数组时，最简单的方法就是给其赋值为 [ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。
·   **对 obiect 进行优化**：对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收

·   **对函数进行优化：**在循环中的函数表达式，如果可以复用，尽量放在函数的外面。







### **2.哪些情况会导致内存泄漏

以下四种情况会造成内存的泄漏：

·   **意外的全局变量：**由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。

·  **被遗忘的计时器或回调函数**：设置了 setlnterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。

·   **脱离 DOM 的引用：**获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这人元素的引用，所以它也无法被回收。
·   **闭包：**不合理的使用闭包，从而导致某些变量一直被留在内存当中。

















